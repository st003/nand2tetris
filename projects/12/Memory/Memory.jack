// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
/**
 * This library provides two services: direct access to the computer's main
 * memory (RAM), and allocation and recycling of memory blocks. The Hack RAM
 * consists of 32,768 words, each holding a 16-bit binary number.
 */ 
class Memory {

    // treat all of the computer RAM as an array
    static Array ram;
    static int heapBase;
    static int maxHeapSize;
    static int freeList;

    /** Initializes the class. */
    function void init() {

        // set the pointer for the ram Array to 0 in order
        // to give Memory access to all the RAM by address
        let ram = 0;

        // Hack computer defined initial location of the heap
        let heapBase = 2048;
        let freeList = heapBase;

        // Hack computer defined max size of heap
        let maxHeapSize = 14336;

        // make entire heap a single heap segment initially
        // configure heap segment header
        let ram[heapBase] = null;
        let ram[heapBase + 1] = maxHeapSize - 2;

        return;
    }

    /** Returns the RAM value at the given address. */
    function int peek(int address) {
        return ram[address];
    }

    /** Sets the RAM value at the given address to the given value. */
    function void poke(int address, int value) {
        let ram[address] = value;
        return;
    }

    /** Finds an available RAM block of the given size and returns
     *  a reference to its base address. */
    function Array alloc(int size) {

        var int curPtr, curSize, curEndPtr;
        var int newPtr, newTotalSize;

        let curPtr = freeList;
        let curSize = ram[curPtr + 1];
        let newTotalSize = size + 2;

        // scan the available heap segments in the free list while
        // the current segement has a pointer to another segment
        while (~(curPtr = null)) {

            // if the given segment has enough space (first-fit algorithim)
            if (~(curSize < newTotalSize)) {

                // allocate a new segement starting from the end of the current segment

                // (1) get the end of the current segment
                // end pointer = segment pointer + header size + block size
                let curEndPtr = curPtr + 2 + curSize;

                // (2) find the head of the new segment by working backwards from the end
                let newPtr = curEndPtr - newTotalSize;

                // (3) configure the new segement's header
                let ram[newPtr] = null;
                let ram[newPtr + 1] = size;

                // (4) update the header of the current segement
                let ram[curPtr + 1] = curSize - newTotalSize;

                // (5) return the new segment's data block
                return ram[newPtr + 2];

            // otherwise, move on to the next heap segment in the list
            } else {
                let curPtr = ram[curPtr];
                let curSize = ram[curPtr + 1];
            }
        }

        // if out of memory error
        do Sys.error(1); // TODO: make class specific error codes
        return null;
    }

    /** De-allocates the given object (cast as an array) by making
     *  it available for future allocations. */
    function void deAlloc(Array o) {

        // traverse the free list until you find a null pointer in a heap segment's next feild
        // then update that null pointer with the address of the newly freed block
        // NOTE: this function does not do any memory defragmentation

        var int next;
        let next = freeList;

        while (~(next = null)) {
            if (ram[next] = null) {
                let ram[next] = o;
                let next = null;
            } else {
                let next = ram[next];
            }
        }

        return 0;
    }
}
